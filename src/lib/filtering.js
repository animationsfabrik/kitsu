import {
  buildNameIndex,
  indexSearch
} from './indexing'

const EQUAL_REGEX = /([^ ]*)=([^ ]*)|\[([^[]*)\]=([^ ]*)/g

/*
 * Look in the search query for task type filter like anim=wip.
 * Then apply filters found on result list.
 */
export const applyFilters = (entries, filters, taskMap) => {
  const isStatus = { status: true }
  const isAssignation = { assignation: true }
  const isExclusion = { exclusion: true }
  const isDescriptor = { descriptor: true }
  const isAttribute = { attribute: true }

  if (filters && filters.length > 0) {
    return entries.filter((entry) => {
      let isOk = true
      filters.forEach((filter) => {
        let task = null
        if (!isOk) return false

        if (filter.taskType && entry.validations[filter.taskType.id]) {
          task = taskMap[entry.validations[filter.taskType.id]]
        }
        if (isStatus[filter.type]) {
          isOk = task && task.task_status_id === filter.taskStatus.id
          if (filter.excluding) isOk = !isOk
        } else if (isAssignation[filter.type]) {
          if (filter.assigned) {
            isOk = task && task.assignees && task.assignees.length > 0
          } else {
            isOk = !task ||
              (task && task.assignees && task.assignees.length === 0)
          }
        } else if (isExclusion[filter.type]) {
          isOk = !filter.excludedIds[entry.id]
        } else if (isDescriptor[filter.type]) {
          if (
            entry.data &&
            entry.data[filter.descriptor.field_name] &&
            filter.value
          ) {
            let dataValue = entry.data[filter.descriptor.field_name]
            dataValue = dataValue.toLowerCase()
            isOk = dataValue.indexOf(filter.value.toLowerCase()) >= 0
          } else {
            isOk = false
          }
          if (filter.excluding) isOk = !isOk
        } else if (isAttribute[filter.type]) {
          if (
            entry &&
            entry[filter.attribute] &&
            filter.value
          ) {
            let dataValue = entry[filter.attribute]
            if (!(typeof dataValue === 'object')) {
              dataValue = dataValue.toLowerCase()
            }
            isOk = dataValue.indexOf(filter.value.toLowerCase()) >= 0
          } else {
            isOk = false
          }
        }
      })
      return isOk
    })
  } else {
    return entries
  }
}

/**
 * Extract keywords from a given text. Remove equality and exclusion
 * expressions.
 */
export const getKeyWords = (queryText) => {
  if (!queryText) {
    return []
  } else {
    return queryText
      .replace(EQUAL_REGEX, '')
      .split(' ')
      .filter((query) => {
        return query.length > 0 && query[0] !== '-'
      })
  }
}

/**
 * Extract excluding keywords from a given text. Remove equality expresions
 * and tradition keywords.
 */
export const getExcludingKeyWords = (queryText) => {
  return queryText
    .replace(EQUAL_REGEX, '')
    .split(' ')
    .filter((keyword) => {
      return keyword.length > 0 && keyword[0] === '-'
    })
    .map(keyword => keyword.substring(1))
}

/*
 * Build all filters data struct generated by a query and return them as
 * an array. It includes:
 * * status filters
 * * assignation filters
 * * exclusion filters
 */
export const getFilters = (
  entryIndex, taskTypes, taskStatuses, descriptors, query
) => {
  let filters = getTaskTypeFilters(taskTypes, taskStatuses, query)
  const descFilters = getDescFilters(descriptors, query)
  const attrFilters = getAttrFilters(query)
  const excludingKeywords = getExcludingKeyWords(query) || []
  filters = filters.concat(descFilters)
  filters = filters.concat(attrFilters)
  excludingKeywords.forEach((keyword) => {
    let excludedMap = {}
    let excludedEntries = indexSearch(entryIndex, [keyword]) || []
    excludedEntries.forEach((entry) => {
      excludedMap[entry.id] = true
    })
    filters.push({
      type: 'exclusion',
      excludedIds: excludedMap
    })
  })
  return filters
}

/*
 *  Extract filters from a query dedicated to task list.
 */
export const getTaskFilters = (entryIndex, query) => {
  const filters = []
  const excludingKeywords = getExcludingKeyWords(query) || []
  excludingKeywords.forEach((keyword) => {
    let excludedMap = {}
    let excludedEntries = indexSearch(entryIndex, [keyword]) || []
    excludedEntries.forEach((entry) => {
      excludedMap[entry.id] = true
    })
    filters.push({
      type: 'exclusion',
      excludedIds: excludedMap
    })
  })
  return filters
}

/*
 * Extract task type filters (like anim=wip or [mode facial]=wip) from given
 * query.
 */
export const getTaskTypeFilters = (
  taskTypes,
  taskStatuses,
  queryText
) => {
  if (!queryText) return []

  const results = []
  const rgxMatches = queryText.match(EQUAL_REGEX)
  const taskTypeNameIndex = buildNameIndex(taskTypes, false)
  const taskStatusShortNameIndex = {}
  taskStatuses.forEach((taskStatus) => {
    taskStatusShortNameIndex[taskStatus.short_name.toLowerCase()] = taskStatus
  })

  if (rgxMatches) {
    rgxMatches.forEach((rgxMatch) => {
      const pattern = rgxMatch.split('=')
      let value = pattern[1]
      const excluding = value.startsWith('-')
      if (excluding) value = value.substring(1)
      let taskTypeName = pattern[0]
      if (taskTypeName[0] === '[') {
        taskTypeName = taskTypeName.substring(1, taskTypeName.length - 1)
      }
      const taskTypes = taskTypeNameIndex[taskTypeName.toLowerCase()]
      if (taskTypes) {
        if (value === 'unassigned') {
          results.push({
            taskType: taskTypes[0],
            assigned: false,
            type: 'assignation'
          })
        } else if (value === 'assigned') {
          results.push({
            taskType: taskTypes[0],
            assigned: true,
            type: 'assignation'
          })
        } else if (value && taskStatusShortNameIndex[value.toLowerCase()]) {
          results.push({
            taskType: taskTypes[0],
            taskStatus: taskStatusShortNameIndex[value.toLowerCase()],
            type: 'status',
            excluding
          })
        }
      }
    })
  }
  return results
}

/*
 * Extract metadata filters (like size=big or size=small) from given
 * query.
 */
export const getDescFilters = (descriptors, queryText) => {
  if (!queryText) return []

  const results = []
  const rgxMatches = queryText.match(EQUAL_REGEX)
  const descriptorNameIndex = buildNameIndex(descriptors, false)

  if (rgxMatches) {
    rgxMatches.forEach((rgxMatch) => {
      const pattern = rgxMatch.split('=')
      let value = pattern[1]
      let descriptorName = pattern[0]
      if (descriptorName[0] === '[') {
        descriptorName = descriptorName.substring(1, descriptorName.length - 1)
      }
      const descriptors = descriptorNameIndex[descriptorName.toLowerCase()]
      const excluding = value.startsWith('-')
      if (excluding) value = value.substring(1)
      if (descriptors) {
        results.push({
          descriptor: descriptors[0],
          value,
          type: 'descriptor',
          excluding
        })
      }
    })
  }
  return results
}

/*
 * Extract metadata filters (like size=big or size=small) from given
 * query.
 */
export const getAttrFilters = (queryText) => {
  if (!queryText) return []
  const results = []
  const attributes = ['sequence_name', 'shot_name']
  const rgxMatches = queryText.match(EQUAL_REGEX)
  if (rgxMatches) {
    rgxMatches.forEach((rgxMatch) => {
      const pattern = rgxMatch.split('=')
      let value = pattern[1]
      let attributeName = pattern[0]
      const excluding = value.startsWith('-')
      if (excluding) value = value.substring(1)
      if (attributes.includes(attributeName)) {
        results.push({
          attribute: attributeName,
          value,
          type: 'attribute',
          excluding
        })
      }
    })
  }
  return results
}
